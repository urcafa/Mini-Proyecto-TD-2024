---
title: "Mini Proyecto TD 2024"
subtitle: "Entrega parcial"
author: |
  Víctor Álvarez Palomares,  
  Sergio Martínez Yagüe,  
  Ferran Medina Mompó,  
  Carles Pascual i Sivera,  
  y Úrsula Casaus Fabra
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción

El objetivo de este proyecto consiste en recoger datos procedentes de distintos tickets de Mercadona para hacer un análisis exploratorio sobre ellos y sacar distintas conclusiones acerca de las compras.

## Carga de librerías y datos necesarios para el análisis

Para cargar las diversas librerías que vamos a utilizar para trabajar en el proyecto, hemos creado una función que las carga todas a la vez sin tener que llamarlas por separado.

## Características generales de los datos

Para poder trabajar con los tickets, necesitamos pasarlos de su formato original (.pdf) a fichero de texto (.txt). Para ello, utilizamos una función de Python con la librería PyPDF2 que hace la conversión. 

Una vez ya los tenemos en el formato deseado, procedemos a almacenar los datos en una lista de data frames que transformamos previamente para que todos los datos puedan analizarse de la misma forma (por ejemplo, la fruta se registra de forma diferente al resto de productos en los tickets, pues el precio varía según el peso). 

Cada data frame contiene registros de 4 variables: "producto" (de tipo caracter), "unidades", "precio_completo" y "precio_individual" (estas de tipo numérico). El número de registros depende de cada data frame, ya que el número de productos varía según la compra.

## Análisis de "missing data" en nuestro conjunto de interés

Por suerte, en nuestros conjuntos de datos no hay "missing data", ya que se tratan de tickets de la compra en los cuales cada producto tiene un nombre y precio asignados, y los tickets contienen la cantidad de veces que se añade a la compra. 

# Importación de los datos

Como ya hemos explicado previamente, hemos convertido nuestros ficheros a .txt desde .pdf. Ahora, creamos funciones que extraigan la información de cada línea del fichero de texto, la separen, y detecten y transformen el formato de la fruta para que encaje con el resto de los datos.

Además, abriremos todos los ficheros a la vez desde la carpeta "data", así nos ahorramos definir nuevos tickets que hemos obtenido a lo largo de la realización del proyecto. 

```{r, echo = FALSE}
# Primero que nada, cargamos las librerías:

install_common_libraries <- function() {
  # Lista de librerías comunes
  common_libraries <- c(
    "ggplot2",
    "dplyr",
    "tidyr",
    "readr",
    "stringr",
    "purrr",
    "tibble",
    "caret",
    "reshape2",
    "ggplot2",
    "lubridate",
    "magrittr",
    "knitr",
    "rmarkdown",
    "shiny",
    "leaflet",
    "plotly", 
    "stringdist"
    # Agrega más librerías según tus necesidades
  )
  
  # Instalar las librerías
  for (lib in common_libraries) {
    if (!requireNamespace(lib, quietly = TRUE)) {
      install.packages(lib, dependencies = TRUE)
    }
  }
  
  print("Instalación completada.")
}

# Llama a la función para instalar las librerías comunes
install_common_libraries()
```

```{r, echo = FALSE, include = FALSE}
# Borramos todas las variables antes de empezar a escribir nuestro código:

rm(list=ls())
```


```{r}
extraer_informacion <- function(archivo) {
  # Leemos el texto desde el archivo
  texto <- readLines(archivo, encoding = "UTF-8")

  # Extraemos la fecha y la hora
  fecha_hora <- substr(texto[5], 1, 16)

  # Como esta información se encuentra en la misma línea de texto la separamos
  fecha <- substr(fecha_hora, 1, 10)
  hora <- substr(fecha_hora, 12, 16)

  # Extraemos la calle
  calle <- grep("C\\/\\s.*\\s\\d+", texto, value = TRUE)
  if (length(calle) == 0) {
    calle <- "Dirección no encontrada"
  }

  # Creamos el data frame
  df <- data.frame(Fecha = fecha, Hora = hora, Calle = calle)
  
  return(df)
}

# En caso de que no esté especificado en el ticket alguna de esta información,
# se indicará que no ha podido ser encontrada
```

```{r}
separar <- function(df) {
  df <- df %>%
    mutate(unidades = as.numeric(substr(producto, 1,1))) %>% 
    # Seleccionamos el número de unidades y hacemos una columna
    mutate(precio_completo =  (substr(producto, nchar(producto) - 3, nchar(producto))), 
           # Seleccionamos el precio y hacemos una columna
           producto = substr(producto, 2, nchar(producto)-4))
           # Borramos las unidades de la columna original
  
  df$precio_completo<- gsub(",", ".", df$precio_completo)
  df$precio_completo <- as.numeric(df$precio_completo)
  #Sustituyo comas por puntos y paso a numerico el precio
  
  df<- df %>% 
    mutate(precio_individual=precio_completo/unidades)
  #Obtengo el precio por unidad a partir del precio completo y las unidades
  
  return(df)
}
```


```{r}
arreglar_fruta <- function(fruta){
  
  # El argumento es un vector con varias frutas y su peso y precio
  
  precios <- fruta[seq_along(fruta) %% 2 == 0]  
  frutas <- fruta[seq_along(fruta) %% 2 != 0] 
  df <- data.frame(frutas = frutas,  precios = precios)
  # Separamos el vector en dos y creo un dataframe
  df <- df %>%
    mutate(unidades = as.numeric(substr(frutas, 1,1)),
           # Seleccionamos el número de unidades y hacemos una columna
           frutas = substr(frutas,2, nchar(frutas)),
           # Borramos el número de unidades de la columna
           peso_kg = substr(precios,1,nchar(precios)-20)) %>%
    # Obtenemos el peso de la columna precios y creamos una columna
    mutate(precio_por_kg = substr(precios,10,14)) %>%
    # Obtenemos el precio por kg de la columna precios y creamos una columna
    mutate(precios = substr(precios,nchar(precios)-4,nchar(precios)))
  # Seleccionamos únicamente el precio de la columna precios
  
  return(df)
}
```



```{r}
detectar_fruta <- function(a){
  texto <-  suppressWarnings(readLines(a, encoding = "UTF-8"))
  # Con UTF-8 daba error en algunos caracteres
  
  indice_parking <- grep("^1PARKING", texto)
  
  if (length(indice_parking) == 0) {
    productos <- texto[8:(length(texto) - 11)]
  } else {
    productos <- texto[8:(indice_parking - 1)]
  }
  # Seleccionamos solo las filas con productos y creamos un dataframe

  while (!grepl("^\\d", tail(productos, 1))) {
    productos <- productos[-length(productos)]
  }
  # Para asegurarnos de incluir todos los productos, seleccionamos líneas de más y 
  # borramos las sobrantes en este bucle
  
  df <- data.frame(producto = productos)
  
  indices <- c()

  for (i in productos){
    idx <- str_detect(i, "^[0-9]{1,3},[0-9]{3}")
    indices <- append(indices, idx)
    
  }
  ind_frut <- which(indices)
  # Detectamos  los índices de las frutas
  
  frutas <- c()
  for (i in ind_frut){
    frutas <- rbind(frutas, df[(i-1), ])
    frutas <- rbind(frutas, df[i, ])

  } 
  
  #Creamos un vector con las frutas y sus precios
  
  for (i in ind_frut){
    df <- subset(df, row.names(df) != i)
    df <- subset(df, row.names(df) != i-1)
  } 
  
  #Quitamos las frutas del dataframe
  
  df_productos<-separar(df)
  
  df_frutas<-arreglar_fruta(frutas)
  
  return(list(df_productos,df_frutas))
}
```

```{r}
tiposIVA<-obtener_caracteres_antes_del_porcentaje <- function(a) {
    texto <-  suppressWarnings(readLines(a, encoding = "latin1"))
    indice1 <- grep("^IVA BASE", texto)
    indice2 <- grep("^TOTAL ", texto)
    IVA <- texto[indice1, indice2]
  return(IVA)
}
```

```{r, include = FALSE}
lista <- list() 
carpeta <- "data"
#Creamos la lista de los ficheros
fichero<-list.files(path = carpeta, full.names = TRUE, recursive = TRUE, pattern = ".txt")
df <- as.data.frame(fichero)

for (i in (1:nrow(df))){
  lista[i] <- extraer_informacion(df$fichero[i])
  lista[i] <- detectar_fruta(df$fichero[i])
  print(lista[i])
}
```

# Preguntas

A continuación vamos a plantearnos diferentes cuestiones que nos podrían venir a la cabeza a la hora de hacer un análisis de los tickets de la compra. 

1) ¿Cuáles son los productos más caros?
2) ¿En qué momento del día se hacen más compras de media?
3) ¿Cuáles son los productos más comprados?
4) ¿Qué días hay compras más grandes?
5) ¿Qué productos tienen distintos tipos de IVA?  
6) ¿Cuántos productos se compran de media en una compra?
7) ¿Qué productos cambian de precio (por kg)?

Además podríamos calcular las distribuciones de compras por categorías de productos para saber qué tipos de productos son los más comprados. A partir de esto también podríamos obtener la distribución de gastos que hace el consumidor a la hora de realizar la compra.

Asimismo, podríamos plantearnos otras cuestiones como el gasto medio de compra, si se hace el pago con efectivo o tarjeta o incluso si los usuarios tienden a ir en coche o a pie (depende de el tamaño de compra, o incluso comodidad).

## ¿Cuáles son los productos más caros?

Para poder obtener esta información, vamos a trabajar solo con las variables "producto" y "precio_individual". Vamos a extraer estas columnas de los data frames y vamos a combinar toda esta información en un único data frame que ordenaremos posteriormente de forma descendente. Cuando ya tengamos la información ordenada, crearemos un gráfico que muestre los 5 productos más caros.

```{r}
# Vamos a recoger solo los precios de los data frames ya que solo queremos
# trabajar con esta variable.

columnas_interes <- c("producto", "precio_individual") # Creamos un vector con
# los nombres de las columnas que queremos del data frame

obtener_precios <- function(lista){
  
  lista_precios <- list() # Creamos la lista vacía
  
  for (i in (1:length(lista))){

    # Seleccionamos las columnas de interés de cada data frame
    
    precios <- subset(lista[[i]], select = columnas_interes)
    
    # Almacenamos cada data frame en una lista con los productos y sus precios
    
    lista_precios[[i]] <- precios
  }
  return(lista_precios)
}

lista_precios <- obtener_precios(lista)
lista_precios

# Ahora, creamos otra función que combine todos los data frames en un único
# data frame y así poder hacer luego un gráfico.

combinar_dataframes <- function(lista_precios) {
  
  # Combinar todos los data frames en uno solo
  df_precios <- bind_rows(lista_precios)
  
  # Eliminar filas duplicadas basadas en la columna "producto", 
  # quedándonos con aquellas de mayor precio

  df_precios <- df_precios %>%
  arrange(producto, desc(precio_individual)) %>%
  distinct(producto, .keep_all = TRUE)

  return(df_precios)
}

df_precios <- combinar_dataframes(lista_precios)

# Ahora, ordenamos el data frame de forma descendente para que nos 
# aparezcan primero los productos más caros.

df_precios <- df_precios[order(df_precios$precio_individual, decreasing = TRUE),]

# Ahora que ya tenemos la información que nos interesa ordenada, vamos a 
# mostrarla con una gráfica.

# Como solo queremos mostrar los 5 primeros, los definimos en otro data frame.

df_precios_plot <- head(df_precios, 5)

grafica <- ggplot(df_precios_plot, aes(x = reorder(producto, precio_individual),
                                       y = precio_individual)) +
  geom_bar(stat = "identity", fill = "seagreen", width = 0.5) +
  labs(title = "Precios de los 5 productos más caros",
       x = "Producto",
       y = "Precio individual") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

grafica

# Si queremos descargarnos el gráfico:

# ggsave("top_5_productos_mas_caros.jpeg", grafica, width = 10, height = 6.5)
```

Como se puede apreciar en la gráfica, los 5 productos más caros son el escalopín de salmón (9,90 €), el jamón de cebo ibérico de cebo (9,79 €), el aceite de oliva virgen extra (9, 55 €), el filete de rodaballo (9,35 €) y la porción de merluza de cabo (8,77 €). Tiene sentido, ya que estos prodcutos suelen ser de gran calidad, y su producción suele ser costosa.

## ¿En qué momento del día se hacen más compras de media?

## ¿Cuáles son los productos más comprados?

Para calcular los productos más vendidos a partir de los tickets de compra, primero vamos a contabilizar la cantidad de cada producto que se compró en cada ticket, lo que nos da un recuento de unidades para cada producto. Tras ello, sumaremos las unidades de cada producto a través de todos los tickets para obtener un total de unidades vendidas para cada producto. Finalmente, ordenamos los productos por el total de unidades vendidas para identificar los productos más vendidos. Es decir, aquellos productos con más unidades vendidas son los productos más vendidos.

```{r, echo=FALSE, warning=FALSE}
library(ggplot2)
# Utilizamos la función que ya tenemos para obtener la lista de dataframes
lista_df <- lista

# Unimos todos los dataframes de los tickets en uno solo
todos_los_tickets <- do.call(rbind, lista_df)
# Eliminamos la última fila del dataframe
todos_los_tickets <- head(todos_los_tickets, -1)

# Convertimos la columna 'unidades' a numérica
todos_los_tickets$unidades <- as.numeric(as.character(todos_los_tickets$unidades))

# Eliminamos las filas con NA (que son las filas que no se pudieron convertir a numérico)
todos_los_tickets <- todos_los_tickets[!is.na(todos_los_tickets$unidades), ]

# A continuación, agrupamos los datos por producto y calculamos las unidades totales de cada producto
productos_por_unidades <- todos_los_tickets %>%
  group_by(producto) %>%
  summarise(
    unidades_total = sum(unidades),
    .groups = 'drop'
  )
# Calcula el número total de tickets
num_tickets <- length(lista_df)

# Calcula la media de unidades por ticket para cada producto
productos_por_unidades <- productos_por_unidades %>%
  mutate(unidades_promedio_por_ticket = unidades_total / num_tickets)

# Ahora, ordenamos los productos por sus unidades promedio por ticket
productos_ordenados <- productos_por_unidades %>%
  arrange(desc(unidades_promedio_por_ticket))

# Finalmente, podemos ver los productos que se compran más según la media de unidades por ticket
top_productos <- head(productos_ordenados)
top_productos

# Creamos un gráfico
grafico <- ggplot(top_productos, aes(x = reorder(producto, -unidades_promedio_por_ticket), y = unidades_promedio_por_ticket)) +
  geom_bar(stat = "identity", fill = "seagreen", width = 0.4) + # cambia el ancho de las barras a 0.5
  theme_minimal() + # usa un tema minimalista
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 6)) +
  ylim(0,2) +
  labs(x = "Producto", y = "Unidades promedio por ticket", title = "Productos más comprados según la media de unidades por ticket")
grafico

#Si queremos descargarnos el gráfico
#ggsave("productos_mas_comprados.jpeg", grafico, width = 10, height = 6.5)
```
Como se puede observar en la gráfica, las bolsas de plástico son el producto más vendido. Con más de 1.1 bolsas de plástico compradas por ticket. Además productos como la chaparta cristal, el zumo fresco, la leche descnatada, la caracola al cacao o el queso a lonchas de cabra también son los más vendidos entre los tickets analizados.

## ¿Qué días hay compras más grandes?

## ¿Qué productos tienen distintos tipos de IVA?  

## ¿Cuántos productos se compran de media en una compra?

Para obtener esta información, necesitamos analizar cada recibo que se pasa a la función. Para determinar el costo total de la compra, utilizamos las funciones "grep" y "sub", que permiten buscar el texto "TOTAL (€)" en cada línea y extraer el valor correspondiente al total de la compra.

Una vez que hemos extraído los precios de todos los recibos, la función calcula la suma de estos valores y luego la divide por el número total de recibos analizados para obtener el promedio del gasto.

Vamos a probar con un ejemplo usando tres tickets de diferentes precios:

```{r}
leer_precio_total <- function(nombres_archivos) {
  precios_totales <- numeric(length(nombres_archivos)) # Vector para almacenar
  # los precios totales
  
  for (i in seq_along(nombres_archivos)) {
    nombre_archivo <- nombres_archivos[i]
    lineas <- readLines(nombre_archivo)
    linea_total <- grep("TOTAL \\(€\\)", lineas, value = TRUE)
    
    if (length(linea_total) > 0) {
      precio_total <- sub(".*TOTAL \\(€\\) ([0-9]+,[0-9]+).*", "\\1", linea_total)
      precios_totales[i] <- as.numeric(gsub(",", ".", precio_total))
    } else {
      precios_totales[i] <- NA
    }
  }
  
  if (all(is.na(precios_totales))) {
    cat("No se pudo leer el precio total de ninguno de los archivos.\n")
  } else {
    cat("Precios total de cada ticket:\n")
    print(precios_totales, na.rm = TRUE)
    precio_medio <- mean(precios_totales, na.rm = TRUE)
    cat(sprintf("Precio medio de los tickets: %.2f €\n", precio_medio))
  }
}

# Usar la función para leer el precio total de múltiples archivos
archivos <- c("data/20240127 Mercadona 108,33.txt", "data/20240129 Mercadona 79,82.txt", "data/20231216 Mercadona 46,19.txt")
leer_precio_total(archivos)

```

Para saber la media de productos por tickets hemos contabilizado todos los productos y a esta cifra le hemos dividido el número total de tickets.

```{r, echo = False}
# Calculamos de la media de productos por ticket con dos decimales
media_productos_por_ticket = round(sum(nrow(todos_los_tickets)) / num_tickets, 2)
```

Observamos que se obtiene que la media de productos por ticket es de **`media_productos_por_ticket`**. Además sabemos que esto va relacionado con el precio de cada compra. Cuantos más productos compres, más cara saldrá la compra.

## ¿Qué productos cambian de precio (por kg)?

En este análisis, exploraremos cómo los precios de ciertos productos varían en función de su peso en las compras realizadas en Mercadona. Para ello, hemos desarrollado una función especializada que recorre el contenido de varios tickets almacenados en archivos de texto. Esta función está diseñada para identificar y extraer información sobre los productos vendidos por peso, capturando tanto el nombre del producto como su precio por kilogramo. 

```{r}
extraer_productos_por_peso <- function(rutas_archivos) {
  # Procesamos cada archivo de ticket proporcionado
  for (ruta_archivo in rutas_archivos) {
    # Leemos el contenido del archivo
    lineas <- readLines(ruta_archivo)
    
    for (i in 2:length(lineas)) {
      # Buscamos las líneas que contienen información de peso y precio por kg
      if (grepl("kg", lineas[i]) && grepl("€/kg", lineas[i])) {
        nombre_producto <- gsub("\\d+", "", lineas[i-1])  # Eliminar números para limpiar el nombre
        nombre_producto <- trimws(nombre_producto)  # Eliminar espacios en blanco sobrantes
        
        # Extraemos la información de peso y precio por kg
        precio_por_kg_info <- regmatches(lineas[i], regexpr("\\d+,\\d+ €/kg", lineas[i]))
        
        descripcion_producto <- sprintf("%s %s", nombre_producto, precio_por_kg_info)
        
        # Mostramos el nombre del producto y su precio por kg
        print(descripcion_producto)
      }
    }
  }
}

```

```{r}
rutas_tickets <- c("data/20240127 Mercadona 108,33.txt","data/20240115 Mercadona 117,41.txt", "data/20240105 Mercadona 63,19.txt")
extraer_productos_por_peso(rutas_tickets)

```

