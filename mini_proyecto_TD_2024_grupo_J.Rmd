---
title: "Mini Proyecto TD 2024"
subtitle: "Entrega parcial"
author: |
  Víctor Álvarez Palomares,  
  Sergio Martínez Yagüe,  
  Ferran Medina Mompó,  
  Carles Pascual i Sivera,  
  y Úrsula Casaus Fabra
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción

En esta primera parte de la entrega, vamos a importar y a analizar la información que nos aportan una serie de tickets de la compra que se nos proporcionan desde la asignatura.  

## Carga de librerías y datos necesarios para el análisis

Para empezar, se cargan todas las librerías necesarias para la realización del código. Esto se hace de manera más elegante utilizando el paquete pacman de RStudio. A continuación, se realiza la carga del conjunto de datos, los cuales se encuentran en formato .pdf. No obstante, no podemos importarlos desde este formato, así que vamos a convertirlos a .txt mediante una función que hemos creado en Python con la librería PyPDF2. De esta forma, obtenemos los ficheros .txt para poder importarlos en RStudio y trabajar con ellos.

## Características generales de los datos

Los datos de los tickets se van a encontrar en listas que contienen dos dataframes: por un lado, el primero contiene todos los productos excepto las frutas y contiene cuatro observaciones (producto, de tipo "char"; unidades, precio_completo y precio_individual, estos de tipo "num"); y por otro lado, un segundo dataframe que contiene los datos solo de las frutas y contiene cinco observaciones (frutas, de tipo "char"; precios, unidades, peso_kg y precio_por_kg, estos de tipo "num").

## Análisis de "missing data" en nuestro conjunto de interés

Por suerte, en nuestros conjuntos de datos no hay "missing data", ya que se tratan de tickets de la compra en los cuales cada producto tiene un nombre y precio asignados, y los tickets contienen la cantidad de veces que se añade a la compra. 

# Importación de los datos

Como ya hemos explicado previamente, hemos convertido nuestros ficheros a .txt desde .pdf. Ahora, vamos a crear otra función para separar las cadenas de caracteres de los ficheros y así importar los datos en los dataframes de forma que nos resulte más fácil trabajar con ellos. También hemos de crear un par de funciones que lean la fruta de forma correcta, pues el formato es distinto al resto de productos.

```{r}
# Primero que nada, cargamos las librerías:

library(pacman)
p_load(dplyr, stringr)


extraer_informacion <- function(archivo) {
  # Leemos el texto desde el archivo
  texto <- readLines(archivo, encoding = "UTF-8")

  # Extraemos la fecha y la hora
  fecha_hora <- substr(texto[5], 1, 16)

  # Como esta información se encuentra en la misma línea de texto la separamos
  fecha <- substr(fecha_hora, 1, 10)
  hora <- substr(fecha_hora, 12, 16)

  # Extraemos la calle
  calle <- grep("C\\/\\s.*\\s\\d+", texto, value = TRUE)
  if (length(calle) == 0) {
    calle <- "Dirección no encontrada"
  }

  # Creamos el data frame
  df <- data.frame(Fecha = fecha, Hora = hora, Calle = calle)
  
  return(df)
}

ticket_a2 <- extraer_informacion("./data/20231218 Mercadona 60,47 Ôé¼.txt")
ticket_b2 <- extraer_informacion("./data/20231224 Mercadona 37,49 Ôé¼.txt")
ticket_c2 <- extraer_informacion("./data/20231226 Mercadona 25,83 Ôé¼.txt")
ticket_c2 <- extraer_informacion("./data/20231230 Mercadona 66,30 Ôé¼.txt")
ticket_d2 <- extraer_informacion("./data/20240102 Mercadona 70,04 Ôé¼.txt")
ticket_e2 <- extraer_informacion("./data/20240108 Mercadona 83,73 Ôé¼.txt")
ticket_f2 <- extraer_informacion("./data/20240109 Mercadona 7,35 Ôé¼.txt")
ticket_g2 <- extraer_informacion("./data/20240109 Mercadona 7,35 Ôé¼.txt")

# En caso de que no esté especificado en el ticket alguna de esta información,
# se indicará que no ha podido ser encontrada

#Mostramos la informacion de un ticket, por ejemplo el ticket a:
ticket_a2
```
```{r}
separar <- function(df) {
  df <- df %>%
    mutate(unidades = as.numeric(substr(producto, 1,1))) %>% 
    # Seleccionamos el número de unidades y hacemos una columna
    mutate(precio_completo =  (substr(producto, nchar(producto) - 3, nchar(producto))), 
           # Seleccionamos el precio y hacemos una columna
           producto = substr(producto, 2, nchar(producto)-4))
           # Borramos las unidades de la columna original
  
  df$precio_completo<- gsub(",", ".", df$precio_completo)
  df$precio_completo <- as.numeric(df$precio_completo)
  #Sustituyo comas por puntos y paso a numerico el precio
  
  df<- df %>% 
    mutate(precio_individual=precio_completo/unidades)
  #Obtengo el precio por unidad a partir del precio completo y las unidades
  
  return(df)
}
```




```{r}
arreglar_fruta <- function(fruta){
  
  # El argumento es un vector con varias frutas y su peso y precio
  
  precios <- fruta[seq_along(fruta) %% 2 == 0]  
  frutas <- fruta[seq_along(fruta) %% 2 != 0] 
  df <- data.frame(frutas = frutas,  precios = precios)
  # Separamos el vector en dos y creo un dataframe
  df <- df %>%
    mutate(unidades = as.numeric(substr(frutas, 1,1)),
           # Seleccionamos el número de unidades y hacemos una columna
           frutas = substr(frutas,2, nchar(frutas)),
           # Borramos el número de unidades de la columna
           peso_kg = substr(precios,1,nchar(precios)-20)) %>%
    # Obtenemos el peso de la columna precios y creamos una columna
    mutate(precio_por_kg = substr(precios,10,14)) %>%
    # Obtenemos el precio por kg de la columna precios y creamos una columna
    mutate(precios = substr(precios,nchar(precios)-4,nchar(precios)))
  # Seleccionamos únicamente el precio de la columna precios
  
  return(df)
}
```



```{r}
detectar_fruta <- function(a){
  texto <-  suppressWarnings(readLines(a, encoding = "latin1"))
  # Con UTF-8 daba error en algunos caracteres
  
  indice_parking <- grep("^1PARKING", texto)
  
  if (length(indice_parking) == 0) {
    productos <- texto[8:(length(texto) - 11)]
  } else {
    productos <- texto[8:(indice_parking - 1)]
  }
  # Seleccionamos solo las filas con productos y creamos un dataframe

  while (!grepl("^\\d", tail(productos, 1))) {
    productos <- productos[-length(productos)]
  }
  # Para asegurarnos de incluir todos los productos, seleccionamos líneas de más y 
  # borramos las sobrantes en este bucle
  
  df <- data.frame(producto = productos)
  
  indices <- c()

  for (i in productos){
    idx <- str_detect(i, "^[0-9]{1,3},[0-9]{3}")
    indices <- append(indices, idx)
    
  }
  ind_frut <- which(indices)
  # Detectamos  los índices de las frutas
  
  frutas <- c()
  for (i in ind_frut){
    frutas <- rbind(frutas, df[(i-1), ])
    frutas <- rbind(frutas, df[i, ])

  } 
  
  #Creamos un vector con las frutas y sus precios
  
  for (i in ind_frut){
    df <- subset(df, row.names(df) != i)
    df <- subset(df, row.names(df) != i-1)
  } 
  
  #Quitamos las frutas del dataframe
  
  df_productos<-separar(df)
  
  df_frutas<-arreglar_fruta(frutas)
  
  return(list(df_productos,df_frutas))
  
  # Devuelve un dataframe con producos y otro con las frutas

}

ticket_a <- detectar_fruta("./data/20231218 Mercadona 60,47 Ôé¼.txt")
ticket_b <- detectar_fruta("./data/20231224 Mercadona 37,49 Ôé¼.txt")
ticket_c <- detectar_fruta("./data/20231226 Mercadona 25,83 Ôé¼.txt")
ticket_d <- detectar_fruta("./data/20231230 Mercadona 66,30 Ôé¼.txt")
ticket_e <- detectar_fruta("./data/20240102 Mercadona 70,04 Ôé¼.txt")
ticket_f <- detectar_fruta("./data/20240108 Mercadona 83,73 Ôé¼.txt")
ticket_g <- detectar_fruta("./data/20240109 Mercadona 7,35 Ôé¼.txt")
ticket_h <- detectar_fruta("./data/20240123 Mercadona 44,13 Ôé¼.txt")
ticket_i <- detectar_fruta("./data/20240127 Mercadona 108,33 Ôé¼.txt")
ticket_h
ticket_i

```

```{r}
tiposIVA<-obtener_caracteres_antes_del_porcentaje <- function(a) {
    texto <-  suppressWarnings(readLines(a, encoding = "latin1"))
  coincidencias <- grep(".*(?=%)", texto, perl = TRUE, value = TRUE)
  return(coincidencias)
}

ticket_a2 <- "./data/20231218 Mercadona 60,47 Ôé¼.txt"
ivas<-tiposIVA(ticket_a2)

    texto <-  suppressWarnings(readLines(ticket_a2, encoding = "latin1"))
texto

```


```{r}
lista <- list() 
carpeta <- "data"
#Creamos la lista de los ficheros
fichero<-list.files(path = carpeta, full.names = TRUE, recursive = TRUE, pattern = ".txt")
df <- as.data.frame(fichero)
for (i in (1:nrow(df))){
  lista[i] <- extraer_informacion(df$fichero[i])
  lista[i] <- detectar_fruta(df$fichero[i])
  print(lista[i])
}


```


# Preguntas

A continuación vamos a plantearnos diferentes cuestiones que nos podrían venir a la cabeza a la hora de hacer un análisis de los tickets de la compra. 

1) ¿Qué productos son los más comprados? 
2) ¿Cuál es el gasto medio de cada compra?
3) ¿Qué nos podría dar a entender la frecuencia de compra de cada usuario
(compras diarias, semanales...)?
4) ¿Qué productos se compran más según el precio de la compra?
5) ¿Qué días hay compras más grandes?
6) ¿Qué productos tienen distintos tipos de IVA?
7) ¿Cuántos productos se compran de media en una compra?
8) ¿Hay algún patrón de compra según la estación del año?
9) ¿Qué productos cambian de precio (por kg)?

Además podríamos calcular las distribuciones de compras por categorías de productos para saber qué tipos de productos son los más comprados. A partir de esto también podríamos obtener la distribución de gastos que hace el consumidor a la hora de realizar la compra.

Asimismo, podríamos plantearnos otras cuestiones como el gasto medio de compra, si se hace el pago con efectivo o tarjeta o incluso si los usuarios tienden a ir en coche o a pie (depende de el tamaño de compra, o incluso comodidad).

