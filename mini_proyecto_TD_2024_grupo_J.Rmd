---
title: "Mini Proyecto TD 2024"
subtitle: "Entrega parcial"
author: |
  Víctor Álvarez Palomares,  
  Sergio Martínez Yagüe,  
  Ferran Medina Mompó,  
  Carles Pascual i Sivera,  
  y Úrsula Casaus Fabra
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción

En esta primera parte de la entrega, vamos a importar y a analizar la información que nos aportan una serie de tickets de la compra que se nos proporcionan desde la asignatura.  

## Carga de librerías y datos necesarios para el análisis

Para empezar, se cargan todas las librerías necesarias para la realización del código. Esto se hace de manera más elegante utilizando el paquete pacman de RStudio. A continuación, se realiza la carga del conjunto de datos, los cuales se encuentran en formato .pdf. No obstante, no podemos importarlos desde este formato, así que vamos a convertirlos a .txt mediante una función que hemos creado en Python con la librería PyPDF2. De esta forma, obtenemos los ficheros .txt para poder importarlos en RStudio y trabajar con ellos.

## Características generales de los datos

Los datos de los tickets se van a encontrar en listas de data frames. Cada dataframe contiene registros de 4 variables: "producto" (de tipo caracter), "unidades", "precio_completo" y "precio_individual" (estas de tipo numérico). El número de registros depende de cada data frame, ya que el número de productos varía según la compra.

## Análisis de "missing data" en nuestro conjunto de interés

Por suerte, en nuestros conjuntos de datos no hay "missing data", ya que se tratan de tickets de la compra en los cuales cada producto tiene un nombre y precio asignados, y los tickets contienen la cantidad de veces que se añade a la compra. 

# Importación de los datos

Como ya hemos explicado previamente, hemos convertido nuestros ficheros a .txt desde .pdf. Ahora, vamos a crear otra función para separar las cadenas de caracteres de los ficheros y así importar los datos en los dataframes de forma que nos resulte más fácil trabajar con ellos. También hemos de crear un par de funciones que lean la fruta de forma correcta, pues el formato es distinto al resto de productos.

```{r, echo = FALSE}
# Primero que nada, cargamos las librerías:
 
library(pacman)
p_load(dplyr, stringr,ggplot2,tidyr)
 
install_common_libraries <- function() {
  # Lista de librerías comunes
  common_libraries <- c(
    "ggplot2",
    "dplyr",
    "tidyr",
    "readr",
    "stringr",
    "purrr",
    "tibble",
    "caret",
    "reshape2",
    "ggplot2",
    "lubridate",
    "magrittr",
    "knitr",
    "rmarkdown",
    "shiny",
    "leaflet",
    "plotly", 
    "stringdist"
    # Agrega más librerías según tus necesidades
  )
  
  # Instalar las librerías
  for (lib in common_libraries) {
    if (!requireNamespace(lib, quietly = TRUE)) {
      install.packages(lib, dependencies = TRUE)
    }
  }
  
  print("Instalación completada.")
} 

  
# Borramos todas las variables antes de empezar a escribir nuestro código:

rm(list=ls())
```


```{r, echo = FALSE} 
extraer_informacion <- function(archivo) {
  # Leemos el texto desde el archivo
  texto <- readLines(archivo, encoding = "UTF-8")

  # Extraemos la fecha y la hora
  fecha_hora <- substr(texto[5], 1, 16)

  # Como esta información se encuentra en la misma línea de texto la separamos
  fecha <- substr(fecha_hora, 1, 10)
  hora <- substr(fecha_hora, 12, 16)

  # Extraemos la calle
  calle <- grep("C\\/\\s.*\\s\\d+", texto, value = TRUE)
  if (length(calle) == 0) {
    calle <- "Dirección no encontrada"
  }

  # Creamos el data frame
  df <- data.frame(Fecha = fecha, Hora = hora, Calle = calle)
  
  return(df)
}


```
```{r, echo = FALSE}
separar <- function(df) {
  df <- df %>%
    mutate(unidades = as.numeric(substr(producto, 1,1))) %>% 
    # Seleccionamos el número de unidades y hacemos una columna
    mutate(precio_completo =  (substr(producto, nchar(producto) - 3, nchar(producto))), 
           # Seleccionamos el precio y hacemos una columna
           producto = substr(producto, 2, nchar(producto)-4))
           # Borramos las unidades de la columna original
  
  df$precio_completo<- gsub(",", ".", df$precio_completo)
  df$precio_completo <- as.numeric(df$precio_completo)
  #Sustituyo comas por puntos y paso a numerico el precio
  
  df<- df %>% 
    mutate(precio_individual=precio_completo/unidades)
  #Obtengo el precio por unidad a partir del precio completo y las unidades
  
  return(df)
}
```




```{r, echo = FALSE}
arreglar_fruta <- function(fruta){
  
  # El argumento es un vector con varias frutas y su peso y precio
  
  precios <- fruta[seq_along(fruta) %% 2 == 0]  
  frutas <- fruta[seq_along(fruta) %% 2 != 0] 
  df <- data.frame(frutas = frutas,  precios = precios)
  # Separamos el vector en dos y creo un dataframe
  df <- df %>%
    mutate(unidades = as.numeric(substr(frutas, 1,1)),
           # Seleccionamos el número de unidades y hacemos una columna
           frutas = substr(frutas,2, nchar(frutas)),
           # Borramos el número de unidades de la columna
           peso_kg = substr(precios,1,nchar(precios)-20)) %>%
    # Obtenemos el peso de la columna precios y creamos una columna
    mutate(precio_por_kg = substr(precios,10,14)) %>%
    # Obtenemos el precio por kg de la columna precios y creamos una columna
    mutate(precios = substr(precios,nchar(precios)-4,nchar(precios)))
  # Seleccionamos únicamente el precio de la columna precios
  
  return(df)
}
```



```{r, echo = FALSE}
detectar_fruta <- function(a){
  texto <-  suppressWarnings(readLines(a, encoding = "windows-1252"))
  # Con UTF-8 daba error en algunos caracteres
  
  indice_parking <- grep("^1PARKING", texto)
  
  if (length(indice_parking) == 0) {
    productos <- texto[8:(length(texto) - 11)]
  } else {
    productos <- texto[8:(indice_parking - 1)]
  }
  # Seleccionamos solo las filas con productos y creamos un dataframe

  while (!grepl("^\\d", tail(productos, 1))) {
    productos <- productos[-length(productos)]
  }
  # Para asegurarnos de incluir todos los productos, seleccionamos líneas de más y 
  # borramos las sobrantes en este bucle
  
  df <- data.frame(producto = productos)
  
  indices <- c()

  for (i in productos){
    idx <- str_detect(i, "^[0-9]{1,3},[0-9]{3}")
    indices <- append(indices, idx)
    
  }
  ind_frut <- which(indices)
  # Detectamos  los índices de las frutas
  
  frutas <- c()
  for (i in ind_frut){
    frutas <- rbind(frutas, df[(i-1), ])
    frutas <- rbind(frutas, df[i, ])

  } 
  
  #Creamos un vector con las frutas y sus precios
  
  for (i in ind_frut){
    df <- subset(df, row.names(df) != i)
    df <- subset(df, row.names(df) != i-1)
  } 
  
  #Quitamos las frutas del dataframe
  
  df_productos<-separar(df)
  
  df_frutas<-arreglar_fruta(frutas)
  
  return(list(df_productos,df_frutas))
  
  # Devuelve un dataframe con producos y otro con las frutas

}
```


 
 
```{r, include = FALSE, echo = FALSE} 
lista <- list() 
carpeta <- "data"
#Creamos la lista de los ficheros
fichero<-list.files(path = carpeta, full.names = TRUE, recursive = TRUE, pattern = ".txt")
df <- as.data.frame(fichero)
for (i in (1:nrow(df))){
  lista[i] <- extraer_informacion(df$fichero[i])
  lista[i] <- detectar_fruta(df$fichero[i])
  print(lista[i])
} 
lista[1]

```



# Preguntas

A continuación vamos a plantearnos diferentes cuestiones que nos podrían venir a la cabeza a la hora de hacer un análisis de los tickets de la compra. 

<<<<<<< HEAD
1) ¿Qué productos son los más comprados? 
=======
1) ¿Cuáles son los productos más caros?
>>>>>>> 255470c808e321d81227200aa5c6197a08111916
2) ¿Cuál es el gasto medio de cada compra?
3) ¿Qué nos podría dar a entender la frecuencia de compra de cada usuario
(compras diarias, semanales...)?
4) ¿Qué productos se compran más según el precio de la compra?
5) ¿Qué días hay compras más grandes?
6) ¿Qué productos tienen distintos tipos de IVA?
7) ¿Cuántos productos se compran de media en una compra?
8) ¿Hay algún patrón de compra según la estación del año?
9) ¿Qué productos cambian de precio (por kg)?

Además podríamos calcular las distribuciones de compras por categorías de productos para saber qué tipos de productos son los más comprados. A partir de esto también podríamos obtener la distribución de gastos que hace el consumidor a la hora de realizar la compra.

Asimismo, podríamos plantearnos otras cuestiones como el gasto medio de compra, si se hace el pago con efectivo o tarjeta o incluso si los usuarios tienden a ir en coche o a pie (depende de el tamaño de compra, o incluso comodidad).

<<<<<<< HEAD
=======
## ¿Cuáles son los productos más caros?

Para poder obtener esta información, vamos a trabajar solo con las variables "producto" y "precio_individual". Vamos a extraer estas columnas de los data frames y vamos a combinar toda esta información en un único data frame que ordenaremos posteriormente de forma descendente. Cuando ya tengamos la información ordenada, crearemos un gráfico que muestre los 5 productos más caros.

```{r, echo = FALSE}
# Vamos a recoger solo los precios de los data frames ya que solo queremos
# trabajar con esta variable.

columnas_interes <- c("producto", "precio_individual") # Creamos un vector con
# los nombres de las columnas que queremos del data frame

obtener_precios <- function(lista){
  
  lista_precios <- list() # Creamos la lista vacía
  
  for (i in (1:length(lista))){

    # Seleccionamos las columnas de interés de cada data frame
    
    precios <- subset(lista[[i]], select = columnas_interes)
    
    # Almacenamos cada data frame en una lista con los productos y sus precios
    
    lista_precios[[i]] <- precios
  }
  return(lista_precios)
}

lista_precios <- obtener_precios(lista)
lista_precios

# Ahora, creamos otra función que combine todos los data frames en un único
# data frame y así poder hacer luego un gráfico.

combinar_dataframes <- function(lista_precios) {
  
  # Combinar todos los data frames en uno solo
  df_precios <- bind_rows(lista_precios)
  
  # Eliminar filas duplicadas basadas en la columna "producto", 
  # quedándonos con aquellas de mayor precio

  df_precios <- df_precios %>%
  arrange(producto, desc(precio_individual)) %>%
  distinct(producto, .keep_all = TRUE)

  return(df_precios)
}

df_precios <- combinar_dataframes(lista_precios)

# Ahora, ordenamos el data frame de forma descendente para que nos 
# aparezcan primero los productos más caros.

df_precios <- df_precios[order(df_precios$precio_individual, decreasing = TRUE),]

# Ahora que ya tenemos la información que nos interesa ordenada, vamos a 
# mostrarla con una gráfica.

# Como solo queremos mostrar los 5 primeros, los definimos en otro data frame.

df_precios_plot <- head(df_precios, 5)

grafica <- ggplot(df_precios_plot, aes(x = reorder(producto, precio_individual),
                                       y = precio_individual)) +
  geom_bar(stat = "identity", fill = "seagreen", width = 0.5) +
  labs(title = "Precios de los 5 productos más caros",
       x = "Producto",
       y = "Precio individual") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

grafica

# Si queremos descargarnos el gráfico:

ggsave("top_5_productos_mas_caros.jpeg", grafica, width = 10, height = 6.5)
```


## ¿Qué productos se compran más?

Para calcular los productos más vendidos a partir de los tickets de compra, primero vamos a contabilizar la cantidad de cada producto que se compró en cada ticket, lo que nos da un recuento de unidades para cada producto. Tras ello, sumaremos las unidades de cada producto a través de todos los tickets para obtener un total de unidades vendidas para cada producto. Finalmente, ordenamos los productos por el total de unidades vendidas para identificar los productos más vendidos. Es decir, aquellos productos con más unidades vendidas son los productos más vendidos.

```{r, echo=FALSE, warning=FALSE}
library(ggplot2)
# Utilizamos la función que ya tenemos para obtener la lista de dataframes
lista_df <- lista

# Unimos todos los dataframes de los tickets en uno solo
todos_los_tickets <- do.call(rbind, lista_df)
# Eliminamos la última fila del dataframe
todos_los_tickets <- head(todos_los_tickets, -1)

# Convertimos la columna 'unidades' a numérica
todos_los_tickets$unidades <- as.numeric(as.character(todos_los_tickets$unidades))

# Eliminamos las filas con NA (que son las filas que no se pudieron convertir a numérico)
todos_los_tickets <- todos_los_tickets[!is.na(todos_los_tickets$unidades), ]

# A continuación, agrupamos los datos por producto y calculamos las unidades totales de cada producto
productos_por_unidades <- todos_los_tickets %>%
  group_by(producto) %>%
  summarise(
    unidades_total = sum(unidades),
    .groups = 'drop'
  )
# Calcula el número total de tickets
num_tickets <- length(lista_df)

# Calcula la media de unidades por ticket para cada producto
productos_por_unidades <- productos_por_unidades %>%
  mutate(unidades_promedio_por_ticket = unidades_total / num_tickets)

# Ahora, ordenamos los productos por sus unidades promedio por ticket
productos_ordenados <- productos_por_unidades %>%
  arrange(desc(unidades_promedio_por_ticket))

# Finalmente, podemos ver los productos que se compran más según la media de unidades por ticket
top_productos <- head(productos_ordenados)
top_productos

# Creamos un gráfico
grafico <- ggplot(top_productos, aes(x = reorder(producto, -unidades_promedio_por_ticket), y = unidades_promedio_por_ticket)) +
  geom_bar(stat = "identity", fill = "seagreen", width = 0.4) + # cambia el ancho de las barras a 0.5
  theme_minimal() + # usa un tema minimalista
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 6)) +
  ylim(0,2) +
  labs(x = "Producto", y = "Unidades promedio por ticket", title = "Productos más comprados según la media de unidades por ticket")
grafico

#Si queremos descargarnos el gráfico
#ggsave("productos_mas_comprados.jpeg", grafico, width = 10, height = 6.5)
```
Como se puede observar en la gráfica, las bolsas de plástico son el producto más vendido. Con más de 1.1 bolsas de plástico compradas por ticket. Además productos como la chaparta cristal, el zumo fresco, la leche descnatada, la caracola al cacao o el queso a lonchas de cabra también son los más vendidos entre los tickets analizados.

## ¿Cuántos productos se compran de media en una compra?

Para saber la media de productos por tickets hemos contabilizado todos los productos y a esta cifra le hemos dividido el número total de tickets.

```{r, echo = FALSE}
# Calculamos de la media de productos por ticket con dos decimales
media_productos_por_ticket = round(sum(nrow(todos_los_tickets)) / num_tickets, 2)
```
Observamos que se obtiene que la media de productos por ticket es de **`media_productos_por_ticket`**. Además sabemos que esto va relacionado con el precio de cada compra. Cuantos más productos compres, más cara saldrá la compra.
# Como solo queremos mostrar los 5 primeros, los definimos en otro data frame.
```{r}
df_precios_plot <- head(df_precios, 5)

grafica <- ggplot(df_precios_plot, aes(x = reorder(producto, precio_individual),
                                       y = precio_individual)) +
  geom_bar(stat = "identity", fill = "seagreen", width = 0.5) +
  labs(title = "Precios de los 5 productos más caros",
       x = "Producto",
       y = "Precio individual") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

grafica

# Si queremos descargarnos el gráfico:

ggsave("top_5_productos_mas_caros.jpeg", grafica, width = 10, height = 6.5)
```

 
## ¿Qué se compra más, comida o bebida? 

Vamos a analizar qué se compra más en general por compra: ¿comida o bebida?
 

```{r, echo = FALSE}
# Definimos las categorías que queremos que aparezcan en los tickets de compra.

categorias <- c("comida", "bebida", "otros")

# Creamos una función para clasificar los productos en las diferentes categorías

clasificar_productos <- function(df) {
  df$categoria <- NA  # Inicializamos la columna de categoría como NA
  
  # Clasificación basada en el nombre del producto
  
  df$categoria <- ifelse(grepl("[A-Za-z]L$", df$producto), "bebida", 
                         ifelse(grepl("comida|alimento|plato|ensalada", tolower(df$producto)), "comida", "otros"))
  
  return(df)
}

# Clasificamos los productos en la lista

lista_con_categorias <- lapply(lista, clasificar_productos)

# Creamos la función que va a añadir a cada fichero la columna categoría 
# con cada producto clasificado.

add_categoria <- function(lista){
  for (i in 1:length(lista)){
    lista[[i]] <- clasificar_productos(lista[[i]])
  }
  return(lista)
}

lista_con_categorias <- add_categoria(lista)
```

## ¿Cuál es el gasto medio de cada compra?

Para obtener esta información, necesitamos analizar cada recibo que se pasa a la función. Para determinar el costo total de la compra, utilizamos las funciones "grep" y "sub", que permiten buscar el texto "TOTAL (€)" en cada línea y extraer el valor correspondiente al total de la compra.

Una vez que hemos extraído los precios de todos los recibos, la función calcula la suma de estos valores y luego la divide por el número total de recibos analizados para obtener el promedio del gasto.

Vamos a probar con un ejemplo usando tres tickets de diferentes precios:

```{r, echo = FALSE}
leer_precio_total <- function(nombres_archivos) {
  precios_totales <- numeric(length(nombres_archivos)) # Vector para almacenar los precios totales
  
  for (i in seq_along(nombres_archivos)) {
    nombre_archivo <- nombres_archivos[i]
    lineas <- readLines(nombre_archivo)
    linea_total <- grep("TOTAL \\(€\\)", lineas, value = TRUE)
    
    if (length(linea_total) > 0) {
      precio_total <- sub(".*TOTAL \\(€\\) ([0-9]+,[0-9]+).*", "\\1", linea_total)
      precios_totales[i] <- as.numeric(gsub(",", ".", precio_total))
    } else {
      precios_totales[i] <- NA
    }
  }
  
  if (all(is.na(precios_totales))) {
    cat("No se pudo leer el precio total de ninguno de los archivos.\n")
  } else {
    cat("Precios total de cada ticket:\n")
    print(precios_totales, na.rm = TRUE)
    precio_medio <- mean(precios_totales, na.rm = TRUE)
    cat(sprintf("Precio medio de los tickets: %.2f €\n", precio_medio))
  }
}

# Usar la función para leer el precio total de múltiples archivos
archivos <- c("data/20240127 Mercadona 108,33.txt", "data/20240129 Mercadona 79,82.txt", "data/20231216 Mercadona 46,19.txt")
leer_precio_total(archivos)

```
 
## ¿Qué productos se compran más?

Para calcular los productos más vendidos a partir de los tickets de compra, primero vamos a contabilizar la cantidad de cada producto que se compró en cada ticket, lo que nos da un recuento de unidades para cada producto. Tras ello, sumaremos las unidades de cada producto a través de todos los tickets para obtener un total de unidades vendidas para cada producto. Finalmente, ordenamos los productos por el total de unidades vendidas para identificar los productos más vendidos. Es decir, aquellos productos con más unidades vendidas son los productos más vendidos.



```{r, echo=FALSE, warning=FALSE}
library(ggplot2)
# Utilizamos la función que ya tenemos para obtener la lista de dataframes
lista_df <- lista

# Unimos todos los dataframes de los tickets en uno solo
todos_los_tickets <- do.call(rbind, lista_df)
# Eliminamos la última fila del dataframe
todos_los_tickets <- head(todos_los_tickets, -1)

# Convertimos la columna 'unidades' a numérica
todos_los_tickets$unidades <- as.numeric(as.character(todos_los_tickets$unidades))

# Eliminamos las filas con NA (que son las filas que no se pudieron convertir a numérico)
todos_los_tickets <- todos_los_tickets[!is.na(todos_los_tickets$unidades), ]

# A continuación, agrupamos los datos por producto y calculamos las unidades totales de cada producto
productos_por_unidades <- todos_los_tickets %>%
  group_by(producto) %>%
  summarise(
    unidades_total = sum(unidades),
    .groups = 'drop'
  )
# Calcula el número total de tickets
num_tickets <- length(lista_df)

# Calcula la media de unidades por ticket para cada producto
productos_por_unidades <- productos_por_unidades %>%
  mutate(unidades_promedio_por_ticket = unidades_total / num_tickets)

# Ahora, ordenamos los productos por sus unidades promedio por ticket
productos_ordenados <- productos_por_unidades %>%
  arrange(desc(unidades_promedio_por_ticket))

# Finalmente, podemos ver los productos que se compran más según la media de unidades por ticket
top_productos <- head(productos_ordenados)
top_productos

# Creamos un gráfico
grafico <- ggplot(top_productos, aes(x = reorder(producto, -unidades_promedio_por_ticket), y = unidades_promedio_por_ticket)) +
  geom_bar(stat = "identity", fill = "seagreen", width = 0.4) + # cambia el ancho de las barras a 0.5
  theme_minimal() + # usa un tema minimalista
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 6)) +
  ylim(0,2) +
  labs(x = "Producto", y = "Unidades promedio por ticket", title = "Productos más comprados según la media de unidades por ticket")
grafico

#Si queremos descargarnos el gráfico
#ggsave("productos_mas_comprados.jpeg", grafico, width = 10, height = 6.5)
```

Como se puede observar en la gráfica, las bolsas de plástico son el producto más vendido. Con más de 1.1 bolsas de plástico compradas por ticket. Además productos como la chaparta cristal, el zumo fresco, la leche descnatada, la caracola al cacao o el queso a lonchas de cabra también son los más vendidos entre los tickets analizados.

## ¿Cuántos productos se compran de media en una compra?

Para saber la media de productos por tickets hemos contabilizado todos los productos y a esta cifra le hemos dividido el número total de tickets.

```{r, echo = FALSE}
# Calculamos de la media de productos por ticket con dos decimales
media_productos_por_ticket = round(sum(nrow(todos_los_tickets)) / num_tickets, 2)
```

 

Observamos que se obtiene que la media de productos por ticket es de **`r media_productos_por_ticket`**. Además sabemos que esto va relacionado con el precio de cada compra. Cuantos más productos compres, más cara saldrá la compra.


## ¿Qué productos cambian de precio (por kg)?

En este análisis, exploraremos cómo los precios de ciertos productos varían en función de su peso en las compras realizadas en Mercadona. Para ello, hemos desarrollado una función especializada que recorre el contenido de varios tickets almacenados en archivos de texto. Esta función está diseñada para identificar y extraer información sobre los productos vendidos por peso, capturando tanto el nombre del producto como su precio por kilogramo. 

```{r, echo = FALSE}
extraer_productos_por_peso <- function(rutas_archivos) {
  # Procesamos cada archivo de ticket proporcionado
  for (ruta_archivo in rutas_archivos) {
    # Leemos el contenido del archivo
    lineas <- readLines(ruta_archivo)
    
    for (i in 2:length(lineas)) {
      # Buscamos las líneas que contienen información de peso y precio por kg
      if (grepl("kg", lineas[i]) && grepl("€/kg", lineas[i])) {
        nombre_producto <- gsub("\\d+", "", lineas[i-1])  # Eliminar números para limpiar el nombre
        nombre_producto <- trimws(nombre_producto)  # Eliminar espacios en blanco sobrantes
        
        # Extraemos la información de peso y precio por kg
        precio_por_kg_info <- regmatches(lineas[i], regexpr("\\d+,\\d+ €/kg", lineas[i]))
        
        descripcion_producto <- sprintf("%s %s", nombre_producto, precio_por_kg_info)
        
        # Mostramos el nombre del producto y su precio por kg
        print(descripcion_producto)
      }
    }
  }
}

```

```{r, echo = FALSE}
rutas_tickets <- c("data/20240127 Mercadona 108,33.txt","data/20240115 Mercadona 117,41.txt", "data/20240105 Mercadona 63,19.txt")
extraer_productos_por_peso(rutas_tickets)

```
 
 
 

```{r, echo = FALSE} 
dfIVA <- function(listaArchivos) {
    dfl <- list()   
    
    for (archivo in listaArchivos) {
        texto <- suppressWarnings(readLines(archivo, encoding = "windows-1252"))
        total1 <- texto[grep("^TOTAL \\(", texto)]
        indice1 <- grep("^IVA BASE", texto)
        indice2 <- grep("^TOTAL \\d", texto)
        IVA <- texto[(indice1 + 1):(indice2 - 1)]
        IVA<- c(IVA,texto[indice2])
        matrizIVA <- matrix(IVA, ncol = 5, byrow = TRUE)
 
        dfIVA <- as.data.frame(matrizIVA)
         
        dfl[[archivo]] <- dfIVA
    }
     
    df_final<-bind_rows(dfl)
    df1 <- df_final %>%
  rowwise() %>%
  mutate(veintiuno = ifelse(any(startsWith(c_across(everything()), "21")), 
                   first(c_across(everything())[startsWith(c_across(everything()), "21")]), 
                   NA))%>%
    mutate(diez = ifelse(any(startsWith(c_across(everything()), "10")), 
                   first(c_across(everything())[startsWith(c_across(everything()), "10")]), 
                   NA))%>%
  mutate(cinco = ifelse(any(startsWith(c_across(everything()), "5")), 
                   first(c_across(everything())[startsWith(c_across(everything()), "5")]), 
                   NA))%>%
  mutate(cero = ifelse(any(startsWith(c_across(everything()), "0")), 
                   first(c_across(everything())[startsWith(c_across(everything()), "0")]), 
                   NA))%>%
  mutate(total = ifelse(any(startsWith(c_across(everything()), "TOTAL")), 
                   first(c_across(everything())[startsWith(c_across(everything()), "TOTAL")]), 
                   NA))
  df <-df1%>%
  select(veintiuno,diez,cinco,cero,total)%>%
  mutate(base21=substr(veintiuno,5,8))%>%
  mutate(base10=substr(diez,5,8))%>%
  mutate(base5=substr(cinco,4,8))%>%
  mutate(base0=substr(cero,4,8))%>%
  mutate(totalBase=substr(total,6,(nchar(total)-4)))%>%
  mutate(imponible21=substr(veintiuno,(nchar(veintiuno)-4),nchar(veintiuno)))%>%
  mutate(imponible10=substr(diez,(nchar(diez)-4),nchar(diez)))%>%
  mutate(imponible5=substr(cinco,(nchar(cinco)-4),nchar(cinco)))%>%
  mutate(imponible0=substr(cero,(nchar(cero)-4),nchar(cero)))%>%
  mutate(totalImponible=substr(total,(nchar(total)-4),nchar(total)))%>%
      select(base21,base10,base5,base0,imponible21,imponible10,imponible5,imponible0,totalBase,totalImponible) %>%
  mutate_all(~ str_replace_all(., ",", "."))%>%
   mutate_all(as.numeric)
    
    return(df)
}
carpeta <- "data"
fichero<-list.files(path = carpeta, full.names = TRUE, recursive = TRUE, pattern = ".txt")

a<-dfIVA(fichero)
a
 
```


En españa el IVA se divide en tres tipos, general(20%), reducido(10%) y superreducido(5%) tambien estoy teniendo en cuenta como otro tipo el 0%, es decir, los productos a los que no se les aplica IVA.
Para empezar a estudiar los datos en boxplot puede ser muy util ya que sirve para hacerse una idea de los valores y detectar posibles outliers.


En este grafico se nota que el IVA reducido es el que tiene un rango de valores mas amplio, y tambien se pueden observar unas pocas observaciones atípicas, pero no me centraré en estudiarlas porque no influyen demasiado en los siguientes gráficos y no son outliers, simplemente compras en las que se ha gastado un poco mas de dinero que el promedio.

```{r, echo = FALSE}


df_long <- gather(a, key = "Variable", value = "Valor")

ggplot(df_long, aes(x = Variable, y = Valor)) +
  geom_boxplot(fill="seagreen") +
  labs(title = "Boxplot de cada Variable", x = "Tipo IVA", y = "Valores")+ 
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 9))
```




En la siguiente grafica se puede observar el precio total al que se le aplica cada tipo de IVA, es decir, de los 1598.87 euros, que es la suma del precio de todos los tickets, se puede ver como principalmente se aplica el IVA reducido(10%)
```{r, echo = FALSE}

graf<-data.frame(tipo=c("0%","5%","10%","20%"),cantidad=c(sum(a$base0, na.rm = T),sum(a$base5, na.rm = T),sum(a$base10, na.rm = T),sum(a$base21, na.rm = T)))  
graf$tipo <- factor(graf$tipo, levels = c("0%", "5%", "10%", "20%"))
ggplot(graf, aes(x = tipo, y = cantidad)) +
  geom_bar(stat = "identity",fill="seagreen") +
  labs(x = "Tipo", y = "Cantidad", title = "Precio del total al que se le aplica cada tipo de IVA")
print(sum(a$totalBase))
```




Para continuar, en esta grafica se puede observar el total imponible de cada tipo de IVA, es decir, de todo el dinero gastado 127.56 euros se han cobrado por el IVA y la mayoria de dinero se ha recaudado por el IVA reducido(10%)


```{r, echo = FALSE}
graf<-data.frame(tipo=c("0%","5%","10%","20%"),cantidad=c(sum(a$imponible0, na.rm = T),sum(a$imponible5, na.rm = T),sum(a$imponible10, na.rm = T),sum(a$imponible21, na.rm = T)))  
graf$tipo <- factor(graf$tipo, levels = c("0%", "5%", "10%", "20%"))
ggplot(graf, aes(x = tipo, y = cantidad)) +
  geom_bar(stat = "identity", fill = "seagreen") +
  labs(x = "Tipo", y = "Precio", title = "Cantidad imponible por tipo")
print(sum(a$totalImponible))
2+2
```





Para terminar, la siguiente grafica muestra la media de cada tipo de IVA tanto el total, como la parte imponible.

```{r, echo = FALSE}
medias<-a %>%group_by()%>% 
  summarise("Total 21%"= mean(base21, na.rm = TRUE),"Total 10%"= mean(base10, na.rm = TRUE),"Total 5%"= mean(base5, na.rm = TRUE),"Total 0%"= mean(base0, na.rm = TRUE),"General(20)"= mean(imponible21, na.rm = TRUE),"reducido(10)"= mean(imponible10, na.rm = TRUE),"superreducido(5)"= mean(imponible5, na.rm = TRUE))
mediasl <- gather(medias, key = "Variable", value = "Valor")
mediasl$Variable <- factor(mediasl$Variable, levels = mediasl$Variable)
mediasl$Categoria <- ifelse(mediasl$Variable %in% c("Total 21%", "Total 10%", "Total 5%", "Total 0%"), "Total", "Imponible")
ggplot(mediasl, aes(x = Variable, y = Valor, fill = Categoria)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("Total" = "#CC6666", "Imponible" = "#66CCCC")) +
  labs(title = "Media del IVA", x = "Precio", y = "Tipo de IVA")+ 
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 9))
 
```


 
